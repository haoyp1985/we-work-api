---
alwaysApply: true
---
# 🏗️ 微服务设计和治理规则

## 🎯 服务拆分规则

### 1. 服务边界划分
```yaml
服务边界原则:
  业务边界: 按领域驱动设计(DDD)划分服务
  数据边界: 每个服务独立数据库，避免共享数据
  团队边界: 服务对应开发团队，便于维护
  技术边界: 避免技术耦合，独立技术栈选择

当前服务规划:
  account-service:    # 账号管理域
    - 企微账号CRUD
    - 账号状态管理
    - 账号配置管理
    
  message-service:    # 消息管理域  
    - 消息发送
    - 模板管理
    - 发送记录
    
  monitor-service:    # 监控域
    - 性能监控
    - 告警管理
    - 统计报表
```

### 2. 服务依赖管理
```java
// ✅ 正确的服务依赖
@FeignClient(name = "account-service", fallback = AccountServiceFallback.class)
public interface AccountServiceClient {
    
    @GetMapping("/api/v1/accounts/{id}")
    Result<AccountDTO> getAccount(@PathVariable String id);
    
    @PostMapping("/api/v1/accounts/{id}/status")
    Result<Void> updateAccountStatus(@PathVariable String id, 
                                   @RequestBody UpdateStatusRequest request);
}

// 降级处理
@Component
public class AccountServiceFallback implements AccountServiceClient {
    
    @Override
    public Result<AccountDTO> getAccount(String id) {
        log.warn("账号服务调用失败，返回默认值");
        return Result.error(ErrorCode.SERVICE_UNAVAILABLE, "账号服务暂时不可用");
    }
    
    @Override
    public Result<Void> updateAccountStatus(String id, UpdateStatusRequest request) {
        log.warn("账号状态更新失败，稍后重试");
        // 可以考虑放入重试队列
        return Result.error(ErrorCode.SERVICE_UNAVAILABLE, "服务暂时不可用");
    }
}
```

## 🔄 服务通信规则

### 1. 同步调用规范
```java
// ✅ 服务间同步调用
@Service
@RequiredArgsConstructor
public class MessageService {
    
    private final AccountServiceClient accountServiceClient;
    
    @HystrixCommand(fallbackMethod = "sendMessageFallback", 
                   commandProperties = {
                       @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds", value = "3000"),
                       @HystrixProperty(name = "circuitBreaker.requestVolumeThreshold", value = "10")
                   })
    public MessageSendResult sendMessage(String tenantId, SendMessageRequest request) {
        // 1. 获取账号信息
        Result<AccountDTO> accountResult = accountServiceClient.getAccount(request.getAccountId());
        if (!accountResult.isSuccess()) {
            throw new BusinessException(ErrorCode.ACCOUNT_NOT_FOUND);
        }
        
        AccountDTO account = accountResult.getData();
        if (!AccountStatus.ONLINE.equals(account.getStatus())) {
            throw new BusinessException(ErrorCode.ACCOUNT_OFFLINE, "账号离线，无法发送消息");
        }
        
        // 2. 发送消息
        return doSendMessage(tenantId, account, request);
    }
    
    // 降级方法
    public MessageSendResult sendMessageFallback(String tenantId, SendMessageRequest request) {
        log.warn("消息发送降级处理, tenantId={}, accountId={}", tenantId, request.getAccountId());
        return MessageSendResult.failure(ErrorCode.SERVICE_DEGRADED.getCode(), "服务繁忙，请稍后重试");
    }
}
```

### 2. 异步通信规范
```java
// ✅ 事件发布
@Service
public class AccountEventPublisher {
    
    @Autowired
    private RocketMQTemplate rocketMQTemplate;
    
    public void publishAccountStatusChanged(String tenantId, String accountId, 
                                          AccountStatus oldStatus, AccountStatus newStatus) {
        AccountStatusChangedEvent event = AccountStatusChangedEvent.builder()
                .tenantId(tenantId)
                .accountId(accountId)
                .oldStatus(oldStatus)
                .newStatus(newStatus)
                .timestamp(System.currentTimeMillis())
                .build();
        
        String destination = "account-events:status-changed";
        rocketMQTemplate.asyncSend(destination, event, new SendCallback() {
            @Override
            public void onSuccess(SendResult sendResult) {
                log.debug("账号状态变更事件发送成功, eventId={}", sendResult.getMsgId());
            }
            
            @Override
            public void onException(Throwable e) {
                log.error("账号状态变更事件发送失败, tenantId={}, accountId={}", 
                         tenantId, accountId, e);
            }
        });
    }
}

// ✅ 事件消费
@Component
@RocketMQMessageListener(
    topic = "account-events",
    selectorExpression = "status-changed",
    consumerGroup = "message-service-group"
)
public class AccountStatusEventListener implements RocketMQListener<AccountStatusChangedEvent> {
    
    @Autowired
    private MessageService messageService;
    
    @Override
    public void onMessage(AccountStatusChangedEvent event) {
        try {
            // 幂等性检查
            if (isEventProcessed(event)) {
                log.debug("事件已处理，跳过, eventId={}", event.getAccountId());
                return;
            }
            
            // 处理业务逻辑
            handleAccountStatusChanged(event);
            
            // 记录处理状态
            markEventProcessed(event);
            
        } catch (Exception e) {
            log.error("处理账号状态变更事件失败", e);
            throw e; // 重新抛出异常，触发重试
        }
    }
    
    private void handleAccountStatusChanged(AccountStatusChangedEvent event) {
        if (AccountStatus.OFFLINE.equals(event.getNewStatus())) {
            // 账号离线，停止相关消息发送任务
            messageService.pauseMessageTasks(event.getTenantId(), event.getAccountId());
        } else if (AccountStatus.ONLINE.equals(event.getNewStatus())) {
            // 账号上线，恢复消息发送任务
            messageService.resumeMessageTasks(event.getTenantId(), event.getAccountId());
        }
    }
}
```

## 🛡️ 服务治理规则

### 1. 服务注册配置
```yaml
# application.yml
spring:
  application:
    name: account-service
  cloud:
    nacos:
      discovery:
        server-addr: ${NACOS_SERVER:localhost:8848}
        namespace: ${NACOS_NAMESPACE:dev}
        group: ${NACOS_GROUP:DEFAULT_GROUP}
        cluster-name: ${CLUSTER_NAME:default}
        metadata:
          version: ${app.version:1.0.0}
          zone: ${app.zone:default}
          weight: 100
        heart-beat-interval: 5000
        heart-beat-timeout: 15000
        ip-delete-timeout: 30000
        
# 健康检查配置
management:
  endpoints:
    web:
      exposure:
        include: health,info,prometheus
  endpoint:
    health:
      show-details: always
  health:
    defaults:
      enabled: true
    diskspace:
      enabled: true
      threshold: 10GB
    db:
      enabled: true
```

### 2. 配置管理规范
```java
// ✅ 外部化配置
@Component
@ConfigurationProperties(prefix = "app.account")
@Data
@RefreshScope  // 支持配置热更新
public class AccountServiceConfig {
    
    private Integer maxAccountsPerTenant = 100;
    private Integer maxRetryCount = 3;
    private Duration requestTimeout = Duration.ofSeconds(30);
    private String defaultWeWorkApiUrl = "https://qyapi.weixin.qq.com";
    
    // 功能开关
    private FeatureFlags features = new FeatureFlags();
    
    @Data
    public static class FeatureFlags {
        private boolean enableAutoRetry = true;
        private boolean enableCircuitBreaker = true;
        private boolean enableRateLimiting = true;
    }
}

// 配置使用
@Service
@RequiredArgsConstructor
public class AccountService {
    
    private final AccountServiceConfig config;
    
    public void createAccount(String tenantId, CreateAccountRequest request) {
        // 检查租户配额
        int currentCount = accountMapper.countByTenantId(tenantId);
        if (currentCount >= config.getMaxAccountsPerTenant()) {
            throw new BusinessException(ErrorCode.ACCOUNT_QUOTA_EXCEEDED);
        }
        
        // 其他业务逻辑
    }
}
```

## 📊 服务监控规则

### 1. 指标监控
```java
// ✅ 业务指标监控
@Component
@RequiredArgsConstructor
public class AccountServiceMetrics {
    
    private final MeterRegistry meterRegistry;
    
    // 计数器
    private final Counter accountCreatedCounter;
    private final Counter accountErrorCounter;
    
    // 计时器
    private final Timer accountCreateTimer;
    
    // 仪表盘
    private final Gauge activeAccountGauge;
    
    @PostConstruct
    public void initMetrics() {
        this.accountCreatedCounter = Counter.builder("account.created.total")
                .description("Total created accounts")
                .tag("service", "account-service")
                .register(meterRegistry);
                
        this.accountErrorCounter = Counter.builder("account.error.total")
                .description("Total account errors")
                .tag("service", "account-service")
                .register(meterRegistry);
                
        this.accountCreateTimer = Timer.builder("account.create.duration")
                .description("Account creation duration")
                .register(meterRegistry);
                
        this.activeAccountGauge = Gauge.builder("account.active.count")
                .description("Active account count")
                .register(meterRegistry, this, AccountServiceMetrics::getActiveAccountCount);
    }
    
    public void recordAccountCreated(String tenantId) {
        accountCreatedCounter.increment(Tags.of("tenant", tenantId));
    }
    
    public void recordAccountError(String tenantId, String errorType) {
        accountErrorCounter.increment(Tags.of("tenant", tenantId, "error", errorType));
    }
    
    public Timer.Sample startCreateTimer() {
        return Timer.start(meterRegistry);
    }
    
    public void recordCreateDuration(Timer.Sample sample, String tenantId) {
        sample.stop(Timer.builder("account.create.duration")
                         .tag("tenant", tenantId)
                         .register(meterRegistry));
    }
    
    private double getActiveAccountCount() {
        // 获取活跃账号数量
        return accountService.getActiveAccountCount();
    }
}
```

### 2. 链路追踪
```java
// ✅ 分布式追踪
@Service
@RequiredArgsConstructor
public class MessageService {
    
    private final Tracer tracer;
    private final AccountServiceClient accountServiceClient;
    
    public MessageSendResult sendMessage(String tenantId, SendMessageRequest request) {
        Span span = tracer.nextSpan()
                .name("message-send")
                .tag("tenant.id", tenantId)
                .tag("message.type", request.getType())
                .start();
        
        try (Tracer.SpanInScope ws = tracer.withSpanInScope(span)) {
            // 1. 获取账号信息
            Span accountSpan = tracer.nextSpan()
                    .name("get-account")
                    .tag("account.id", request.getAccountId())
                    .start();
            
            try (Tracer.SpanInScope accountWs = tracer.withSpanInScope(accountSpan)) {
                Result<AccountDTO> accountResult = accountServiceClient.getAccount(request.getAccountId());
                accountSpan.tag("account.status", accountResult.getData().getStatus().name());
            } finally {
                accountSpan.end();
            }
            
            // 2. 发送消息
            MessageSendResult result = doSendMessage(tenantId, request);
            span.tag("message.id", result.getMessageId());
            span.tag("send.status", result.isSuccess() ? "success" : "failed");
            
            return result;
            
        } catch (Exception e) {
            span.tag("error", e.getMessage());
            throw e;
        } finally {
            span.end();
        }
    }
}
```

## 🔄 部署和扩展规则

### 1. 容器化部署
```dockerfile
# ✅ 标准Dockerfile
FROM openjdk:17-jdk-slim as builder

WORKDIR /app
COPY pom.xml .
COPY src ./src
RUN ./mvnw clean package -DskipTests

FROM openjdk:17-jre-slim

# 创建应用用户
RUN groupadd -r appgroup && useradd -r -g appgroup appuser

WORKDIR /app

# 复制应用
COPY --from=builder /app/target/*.jar app.jar

# 设置时区
ENV TZ=Asia/Shanghai
RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime && echo $TZ > /etc/timezone

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=60s --retries=3 \
  CMD curl -f http://localhost:8080/actuator/health || exit 1

# 切换用户
USER appuser

EXPOSE 8080

# JVM参数优化
ENV JAVA_OPTS="-Xms512m -Xmx1024m -XX:+UseG1GC -XX:+UseContainerSupport"

ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

### 2. 自动扩缩容配置
```yaml
# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: account-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: account-service
  template:
    metadata:
      labels:
        app: account-service
    spec:
      containers:
      - name: account-service
        image: account-service:latest
        ports:
        - containerPort: 8080
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        env:
        - name: PROFILE
          value: "prod"
        - name: NACOS_ADDR
          value: "nacos:8848"
        readinessProbe:
          httpGet:
            path: /actuator/health/readiness
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        livenessProbe:
          httpGet:
            path: /actuator/health/liveness
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 30

---
# HPA配置
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: account-service-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: account-service
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
```

**规则总结**:
- 按业务域进行服务拆分，避免技术耦合
- 服务间通信优先使用异步消息，关键路径同步调用
- 配置外部化，支持热更新和环境隔离
- 完善监控指标和链路追踪
- 标准化容器部署，支持自动扩缩容# 🏗️ 微服务设计和治理规则

## 🎯 服务拆分规则

### 1. 服务边界划分
```yaml
服务边界原则:
  业务边界: 按领域驱动设计(DDD)划分服务
  数据边界: 每个服务独立数据库，避免共享数据
  团队边界: 服务对应开发团队，便于维护
  技术边界: 避免技术耦合，独立技术栈选择

当前服务规划:
  account-service:    # 账号管理域
    - 企微账号CRUD
    - 账号状态管理
    - 账号配置管理
    
  message-service:    # 消息管理域  
    - 消息发送
    - 模板管理
    - 发送记录
    
  monitor-service:    # 监控域
    - 性能监控
    - 告警管理
    - 统计报表
```

### 2. 服务依赖管理
```java
// ✅ 正确的服务依赖
@FeignClient(name = "account-service", fallback = AccountServiceFallback.class)
public interface AccountServiceClient {
    
    @GetMapping("/api/v1/accounts/{id}")
    Result<AccountDTO> getAccount(@PathVariable String id);
    
    @PostMapping("/api/v1/accounts/{id}/status")
    Result<Void> updateAccountStatus(@PathVariable String id, 
                                   @RequestBody UpdateStatusRequest request);
}

// 降级处理
@Component
public class AccountServiceFallback implements AccountServiceClient {
    
    @Override
    public Result<AccountDTO> getAccount(String id) {
        log.warn("账号服务调用失败，返回默认值");
        return Result.error(ErrorCode.SERVICE_UNAVAILABLE, "账号服务暂时不可用");
    }
    
    @Override
    public Result<Void> updateAccountStatus(String id, UpdateStatusRequest request) {
        log.warn("账号状态更新失败，稍后重试");
        // 可以考虑放入重试队列
        return Result.error(ErrorCode.SERVICE_UNAVAILABLE, "服务暂时不可用");
    }
}
```

## 🔄 服务通信规则

### 1. 同步调用规范
```java
// ✅ 服务间同步调用
@Service
@RequiredArgsConstructor
public class MessageService {
    
    private final AccountServiceClient accountServiceClient;
    
    @HystrixCommand(fallbackMethod = "sendMessageFallback", 
                   commandProperties = {
                       @HystrixProperty(name = "execution.isolation.thread.timeoutInMilliseconds", value = "3000"),
                       @HystrixProperty(name = "circuitBreaker.requestVolumeThreshold", value = "10")
                   })
    public MessageSendResult sendMessage(String tenantId, SendMessageRequest request) {
        // 1. 获取账号信息
        Result<AccountDTO> accountResult = accountServiceClient.getAccount(request.getAccountId());
        if (!accountResult.isSuccess()) {
            throw new BusinessException(ErrorCode.ACCOUNT_NOT_FOUND);
        }
        
        AccountDTO account = accountResult.getData();
        if (!AccountStatus.ONLINE.equals(account.getStatus())) {
            throw new BusinessException(ErrorCode.ACCOUNT_OFFLINE, "账号离线，无法发送消息");
        }
        
        // 2. 发送消息
        return doSendMessage(tenantId, account, request);
    }
    
    // 降级方法
    public MessageSendResult sendMessageFallback(String tenantId, SendMessageRequest request) {
        log.warn("消息发送降级处理, tenantId={}, accountId={}", tenantId, request.getAccountId());
        return MessageSendResult.failure(ErrorCode.SERVICE_DEGRADED.getCode(), "服务繁忙，请稍后重试");
    }
}
```

### 2. 异步通信规范
```java
// ✅ 事件发布
@Service
public class AccountEventPublisher {
    
    @Autowired
    private RocketMQTemplate rocketMQTemplate;
    
    public void publishAccountStatusChanged(String tenantId, String accountId, 
                                          AccountStatus oldStatus, AccountStatus newStatus) {
        AccountStatusChangedEvent event = AccountStatusChangedEvent.builder()
                .tenantId(tenantId)
                .accountId(accountId)
                .oldStatus(oldStatus)
                .newStatus(newStatus)
                .timestamp(System.currentTimeMillis())
                .build();
        
        String destination = "account-events:status-changed";
        rocketMQTemplate.asyncSend(destination, event, new SendCallback() {
            @Override
            public void onSuccess(SendResult sendResult) {
                log.debug("账号状态变更事件发送成功, eventId={}", sendResult.getMsgId());
            }
            
            @Override
            public void onException(Throwable e) {
                log.error("账号状态变更事件发送失败, tenantId={}, accountId={}", 
                         tenantId, accountId, e);
            }
        });
    }
}

// ✅ 事件消费
@Component
@RocketMQMessageListener(
    topic = "account-events",
    selectorExpression = "status-changed",
    consumerGroup = "message-service-group"
)
public class AccountStatusEventListener implements RocketMQListener<AccountStatusChangedEvent> {
    
    @Autowired
    private MessageService messageService;
    
    @Override
    public void onMessage(AccountStatusChangedEvent event) {
        try {
            // 幂等性检查
            if (isEventProcessed(event)) {
                log.debug("事件已处理，跳过, eventId={}", event.getAccountId());
                return;
            }
            
            // 处理业务逻辑
            handleAccountStatusChanged(event);
            
            // 记录处理状态
            markEventProcessed(event);
            
        } catch (Exception e) {
            log.error("处理账号状态变更事件失败", e);
            throw e; // 重新抛出异常，触发重试
        }
    }
    
    private void handleAccountStatusChanged(AccountStatusChangedEvent event) {
        if (AccountStatus.OFFLINE.equals(event.getNewStatus())) {
            // 账号离线，停止相关消息发送任务
            messageService.pauseMessageTasks(event.getTenantId(), event.getAccountId());
        } else if (AccountStatus.ONLINE.equals(event.getNewStatus())) {
            // 账号上线，恢复消息发送任务
            messageService.resumeMessageTasks(event.getTenantId(), event.getAccountId());
        }
    }
}
```

## 🛡️ 服务治理规则

### 1. 服务注册配置
```yaml
# application.yml
spring:
  application:
    name: account-service
  cloud:
    nacos:
      discovery:
        server-addr: ${NACOS_SERVER:localhost:8848}
        namespace: ${NACOS_NAMESPACE:dev}
        group: ${NACOS_GROUP:DEFAULT_GROUP}
        cluster-name: ${CLUSTER_NAME:default}
        metadata:
          version: ${app.version:1.0.0}
          zone: ${app.zone:default}
          weight: 100
        heart-beat-interval: 5000
        heart-beat-timeout: 15000
        ip-delete-timeout: 30000
        
# 健康检查配置
management:
  endpoints:
    web:
      exposure:
        include: health,info,prometheus
  endpoint:
    health:
      show-details: always
  health:
    defaults:
      enabled: true
    diskspace:
      enabled: true
      threshold: 10GB
    db:
      enabled: true
```

### 2. 配置管理规范
```java
// ✅ 外部化配置
@Component
@ConfigurationProperties(prefix = "app.account")
@Data
@RefreshScope  // 支持配置热更新
public class AccountServiceConfig {
    
    private Integer maxAccountsPerTenant = 100;
    private Integer maxRetryCount = 3;
    private Duration requestTimeout = Duration.ofSeconds(30);
    private String defaultWeWorkApiUrl = "https://qyapi.weixin.qq.com";
    
    // 功能开关
    private FeatureFlags features = new FeatureFlags();
    
    @Data
    public static class FeatureFlags {
        private boolean enableAutoRetry = true;
        private boolean enableCircuitBreaker = true;
        private boolean enableRateLimiting = true;
    }
}

// 配置使用
@Service
@RequiredArgsConstructor
public class AccountService {
    
    private final AccountServiceConfig config;
    
    public void createAccount(String tenantId, CreateAccountRequest request) {
        // 检查租户配额
        int currentCount = accountMapper.countByTenantId(tenantId);
        if (currentCount >= config.getMaxAccountsPerTenant()) {
            throw new BusinessException(ErrorCode.ACCOUNT_QUOTA_EXCEEDED);
        }
        
        // 其他业务逻辑
    }
}
```

## 📊 服务监控规则

### 1. 指标监控
```java
// ✅ 业务指标监控
@Component
@RequiredArgsConstructor
public class AccountServiceMetrics {
    
    private final MeterRegistry meterRegistry;
    
    // 计数器
    private final Counter accountCreatedCounter;
    private final Counter accountErrorCounter;
    
    // 计时器
    private final Timer accountCreateTimer;
    
    // 仪表盘
    private final Gauge activeAccountGauge;
    
    @PostConstruct
    public void initMetrics() {
        this.accountCreatedCounter = Counter.builder("account.created.total")
                .description("Total created accounts")
                .tag("service", "account-service")
                .register(meterRegistry);
                
        this.accountErrorCounter = Counter.builder("account.error.total")
                .description("Total account errors")
                .tag("service", "account-service")
                .register(meterRegistry);
                
        this.accountCreateTimer = Timer.builder("account.create.duration")
                .description("Account creation duration")
                .register(meterRegistry);
                
        this.activeAccountGauge = Gauge.builder("account.active.count")
                .description("Active account count")
                .register(meterRegistry, this, AccountServiceMetrics::getActiveAccountCount);
    }
    
    public void recordAccountCreated(String tenantId) {
        accountCreatedCounter.increment(Tags.of("tenant", tenantId));
    }
    
    public void recordAccountError(String tenantId, String errorType) {
        accountErrorCounter.increment(Tags.of("tenant", tenantId, "error", errorType));
    }
    
    public Timer.Sample startCreateTimer() {
        return Timer.start(meterRegistry);
    }
    
    public void recordCreateDuration(Timer.Sample sample, String tenantId) {
        sample.stop(Timer.builder("account.create.duration")
                         .tag("tenant", tenantId)
                         .register(meterRegistry));
    }
    
    private double getActiveAccountCount() {
        // 获取活跃账号数量
        return accountService.getActiveAccountCount();
    }
}
```

### 2. 链路追踪
```java
// ✅ 分布式追踪
@Service
@RequiredArgsConstructor
public class MessageService {
    
    private final Tracer tracer;
    private final AccountServiceClient accountServiceClient;
    
    public MessageSendResult sendMessage(String tenantId, SendMessageRequest request) {
        Span span = tracer.nextSpan()
                .name("message-send")
                .tag("tenant.id", tenantId)
                .tag("message.type", request.getType())
                .start();
        
        try (Tracer.SpanInScope ws = tracer.withSpanInScope(span)) {
            // 1. 获取账号信息
            Span accountSpan = tracer.nextSpan()
                    .name("get-account")
                    .tag("account.id", request.getAccountId())
                    .start();
            
            try (Tracer.SpanInScope accountWs = tracer.withSpanInScope(accountSpan)) {
                Result<AccountDTO> accountResult = accountServiceClient.getAccount(request.getAccountId());
                accountSpan.tag("account.status", accountResult.getData().getStatus().name());
            } finally {
                accountSpan.end();
            }
            
            // 2. 发送消息
            MessageSendResult result = doSendMessage(tenantId, request);
            span.tag("message.id", result.getMessageId());
            span.tag("send.status", result.isSuccess() ? "success" : "failed");
            
            return result;
            
        } catch (Exception e) {
            span.tag("error", e.getMessage());
            throw e;
        } finally {
            span.end();
        }
    }
}
```

## 🔄 部署和扩展规则

### 1. 容器化部署
```dockerfile
# ✅ 标准Dockerfile
FROM openjdk:17-jdk-slim as builder

WORKDIR /app
COPY pom.xml .
COPY src ./src
RUN ./mvnw clean package -DskipTests

FROM openjdk:17-jre-slim

# 创建应用用户
RUN groupadd -r appgroup && useradd -r -g appgroup appuser

WORKDIR /app

# 复制应用
COPY --from=builder /app/target/*.jar app.jar

# 设置时区
ENV TZ=Asia/Shanghai
RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime && echo $TZ > /etc/timezone

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=60s --retries=3 \
  CMD curl -f http://localhost:8080/actuator/health || exit 1

# 切换用户
USER appuser

EXPOSE 8080

# JVM参数优化
ENV JAVA_OPTS="-Xms512m -Xmx1024m -XX:+UseG1GC -XX:+UseContainerSupport"

ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

### 2. 自动扩缩容配置
```yaml
# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: account-service
spec:
  replicas: 3
  selector:
    matchLabels:
      app: account-service
  template:
    metadata:
      labels:
        app: account-service
    spec:
      containers:
      - name: account-service
        image: account-service:latest
        ports:
        - containerPort: 8080
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        env:
        - name: PROFILE
          value: "prod"
        - name: NACOS_ADDR
          value: "nacos:8848"
        readinessProbe:
          httpGet:
            path: /actuator/health/readiness
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        livenessProbe:
          httpGet:
            path: /actuator/health/liveness
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 30

---
# HPA配置
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: account-service-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: account-service
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80
```

**规则总结**:
- 按业务域进行服务拆分，避免技术耦合
- 服务间通信优先使用异步消息，关键路径同步调用
- 配置外部化，支持热更新和环境隔离
- 完善监控指标和链路追踪
- 标准化容器部署，支持自动扩缩容