---
alwaysApply: true
---

# ğŸ” å®‰å…¨è®¾è®¡å’Œå®ç°è§„åˆ™

## ğŸ›¡ï¸ è®¤è¯æˆæƒè§„åˆ™

### 1. JWT Tokenç®¡ç†
```java
// âœ… JWTå·¥å…·ç±»å®ç°
@Component
@ConfigurationProperties(prefix = "app.jwt")
@Data
public class JwtUtils {
    
    private String secretKey = "default-secret-key-change-in-production";
    private long accessTokenExpiration = 7200000; // 2å°æ—¶
    private long refreshTokenExpiration = 604800000; // 7å¤©
    private String issuer = "wework-platform";
    
    private final Algorithm algorithm = Algorithm.HMAC256(secretKey);
    
    public String generateAccessToken(UserContext userContext) {
        return JWT.create()
                .withIssuer(issuer)
                .withSubject(userContext.getUserId())
                .withClaim("tenantId", userContext.getTenantId())
                .withClaim("username", userContext.getUsername())
                .withClaim("roles", userContext.getRoles())
                .withClaim("permissions", userContext.getPermissions())
                .withClaim("tokenType", "access")
                .withIssuedAt(new Date())
                .withExpiresAt(new Date(System.currentTimeMillis() + accessTokenExpiration))
                .sign(algorithm);
    }
    
    public String generateRefreshToken(String userId) {
        return JWT.create()
                .withIssuer(issuer)
                .withSubject(userId)
                .withClaim("tokenType", "refresh")
                .withIssuedAt(new Date())
                .withExpiresAt(new Date(System.currentTimeMillis() + refreshTokenExpiration))
                .sign(algorithm);
    }
    
    public boolean validateToken(String token) {
        try {
            JWTVerifier verifier = JWT.require(algorithm)
                    .withIssuer(issuer)
                    .build();
            verifier.verify(token);
            return true;
        } catch (JWTVerificationException e) {
            log.warn("TokenéªŒè¯å¤±è´¥: {}", e.getMessage());
            return false;
        }
    }
    
    public UserContext parseToken(String token) {
        try {
            DecodedJWT jwt = JWT.decode(token);
            return UserContext.builder()
                    .userId(jwt.getSubject())
                    .tenantId(jwt.getClaim("tenantId").asString())
                    .username(jwt.getClaim("username").asString())
                    .roles(jwt.getClaim("roles").asList(String.class))
                    .permissions(jwt.getClaim("permissions").asList(String.class))
                    .build();
        } catch (Exception e) {
            throw new SecurityException("Tokenè§£æå¤±è´¥", e);
        }
    }
}
```

### 2. æƒé™æ§åˆ¶å®ç°
```java
// âœ… åŸºäºæ³¨è§£çš„æƒé™æ§åˆ¶
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RequirePermission {
    String resource();
    String action();
}

@Component
@RequiredArgsConstructor
public class PermissionService {
    
    private final RedisTemplate<String, Object> redisTemplate;
    
    public boolean hasPermission(String userId, String tenantId, String resource, String action) {
        // 1. ä»ç¼“å­˜è·å–ç”¨æˆ·æƒé™
        String cacheKey = String.format("user:permissions:%s:%s", tenantId, userId);
        Set<String> permissions = (Set<String>) redisTemplate.opsForValue().get(cacheKey);
        
        if (permissions == null) {
            // 2. ä»æ•°æ®åº“åŠ è½½æƒé™
            permissions = loadUserPermissions(userId, tenantId);
            // 3. ç¼“å­˜æƒé™(30åˆ†é’Ÿ)
            redisTemplate.opsForValue().set(cacheKey, permissions, Duration.ofMinutes(30));
        }
        
        // 4. æ£€æŸ¥æƒé™
        String permission = resource + ":" + action;
        return permissions.contains(permission) || permissions.contains("*:*");
    }
    
    private Set<String> loadUserPermissions(String userId, String tenantId) {
        // æŸ¥è¯¢ç”¨æˆ·è§’è‰²
        List<String> roles = userRoleMapper.selectRolesByUserId(userId, tenantId);
        
        // æŸ¥è¯¢è§’è‰²æƒé™
        Set<String> permissions = new HashSet<>();
        for (String role : roles) {
            List<String> rolePermissions = rolePermissionMapper.selectPermissionsByRole(role, tenantId);
            permissions.addAll(rolePermissions);
        }
        
        return permissions;
    }
}

// AOPæƒé™æ‹¦æˆªå™¨
@Aspect
@Component
@RequiredArgsConstructor
public class PermissionAspect {
    
    private final PermissionService permissionService;
    
    @Around("@annotation(requirePermission)")
    public Object checkPermission(ProceedingJoinPoint point, RequirePermission requirePermission) throws Throwable {
        UserContext userContext = UserContextHolder.getContext();
        if (userContext == null) {
            throw new SecurityException("ç”¨æˆ·æœªç™»å½•");
        }
        
        boolean hasPermission = permissionService.hasPermission(
                userContext.getUserId(),
                userContext.getTenantId(),
                requirePermission.resource(),
                requirePermission.action()
        );
        
        if (!hasPermission) {
            throw new BusinessException(ErrorCode.FORBIDDEN, 
                    String.format("æ— æƒé™æ‰§è¡Œæ“ä½œ: %s:%s", 
                                 requirePermission.resource(), 
                                 requirePermission.action()));
        }
        
        return point.proceed();
    }
}
```

## ğŸ”’ æ•°æ®å®‰å…¨è§„åˆ™

### 1. æ•æ„Ÿæ•°æ®åŠ å¯†
```java
// âœ… æ•°æ®åŠ å¯†å·¥å…·
@Component
public class CryptoUtils {
    
    private static final String AES_ALGORITHM = "AES/CBC/PKCS5Padding";
    private static final String KEY_ALGORITHM = "AES";
    private static final int KEY_LENGTH = 256;
    
    @Value("${app.security.encrypt.key}")
    private String encryptKey;
    
    public String encrypt(String plainText) {
        if (StringUtils.isBlank(plainText)) {
            return plainText;
        }
        
        try {
            SecretKeySpec keySpec = new SecretKeySpec(encryptKey.getBytes(), KEY_ALGORITHM);
            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);
            
            // ç”ŸæˆéšæœºIV
            byte[] iv = new byte[16];
            new SecureRandom().nextBytes(iv);
            IvParameterSpec ivSpec = new IvParameterSpec(iv);
            
            cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);
            byte[] encrypted = cipher.doFinal(plainText.getBytes(StandardCharsets.UTF_8));
            
            // IV + åŠ å¯†æ•°æ®
            byte[] result = new byte[iv.length + encrypted.length];
            System.arraycopy(iv, 0, result, 0, iv.length);
            System.arraycopy(encrypted, 0, result, iv.length, encrypted.length);
            
            return Base64.getEncoder().encodeToString(result);
            
        } catch (Exception e) {
            throw new SecurityException("æ•°æ®åŠ å¯†å¤±è´¥", e);
        }
    }
    
    public String decrypt(String encryptedText) {
        if (StringUtils.isBlank(encryptedText)) {
            return encryptedText;
        }
        
        try {
            byte[] data = Base64.getDecoder().decode(encryptedText);
            
            // æå–IV
            byte[] iv = new byte[16];
            System.arraycopy(data, 0, iv, 0, 16);
            
            // æå–åŠ å¯†æ•°æ®
            byte[] encrypted = new byte[data.length - 16];
            System.arraycopy(data, 16, encrypted, 0, encrypted.length);
            
            SecretKeySpec keySpec = new SecretKeySpec(encryptKey.getBytes(), KEY_ALGORITHM);
            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);
            IvParameterSpec ivSpec = new IvParameterSpec(iv);
            
            cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);
            byte[] decrypted = cipher.doFinal(encrypted);
            
            return new String(decrypted, StandardCharsets.UTF_8);
            
        } catch (Exception e) {
            throw new SecurityException("æ•°æ®è§£å¯†å¤±è´¥", e);
        }
    }
}

// æ•æ„Ÿå­—æ®µè‡ªåŠ¨åŠ å¯†
@Component
public class SensitiveDataHandler implements TypeHandler<String> {
    
    @Autowired
    private CryptoUtils cryptoUtils;
    
    @Override
    public void setParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException {
        if (parameter != null) {
            ps.setString(i, cryptoUtils.encrypt(parameter));
        } else {
            ps.setString(i, null);
        }
    }
    
    @Override
    public String getResult(ResultSet rs, String columnName) throws SQLException {
        String encrypted = rs.getString(columnName);
        return encrypted != null ? cryptoUtils.decrypt(encrypted) : null;
    }
}
```

### 2. SQLæ³¨å…¥é˜²æŠ¤
```java
// âœ… é˜²SQLæ³¨å…¥è§„èŒƒ
@Repository
public class AccountMapper {
    
    // æ­£ç¡®ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢
    @Select("SELECT * FROM wework_accounts WHERE tenant_id = #{tenantId} AND account_name = #{accountName}")
    WeWorkAccount selectByTenantAndName(@Param("tenantId") String tenantId, 
                                       @Param("accountName") String accountName);
    
    // åŠ¨æ€SQLä½¿ç”¨#{}å‚æ•°ç»‘å®š
    List<WeWorkAccount> selectByConditions(AccountQueryDTO query) {
        return sqlSession.selectList("selectByConditions", query);
    }
    
    // âŒ é”™è¯¯ï¼šå­—ç¬¦ä¸²æ‹¼æ¥å®¹æ˜“SQLæ³¨å…¥
    // String sql = "SELECT * FROM accounts WHERE name = '" + name + "'";
}

// MyBatisåŠ¨æ€SQL
@Mapper
public interface AccountMapper {
    
    List<WeWorkAccount> selectByDynamicConditions(@Param("query") AccountQueryDTO query);
}

<!-- account-mapper.xml -->
<select id="selectByDynamicConditions" resultType="WeWorkAccount">
    SELECT * FROM wework_accounts 
    WHERE tenant_id = #{query.tenantId}
    <if test="query.accountName != null and query.accountName != ''">
        AND account_name LIKE CONCAT('%', #{query.accountName}, '%')
    </if>
    <if test="query.status != null">
        AND status = #{query.status}
    </if>
    <if test="query.startDate != null">
        AND created_at >= #{query.startDate}
    </if>
    ORDER BY created_at DESC
    LIMIT #{query.offset}, #{query.limit}
</select>
```

## ğŸ” APIå®‰å…¨è§„åˆ™

### 1. è¯·æ±‚ç­¾åéªŒè¯
```java
// âœ… APIç­¾åéªŒè¯
@Component
public class ApiSignatureValidator {
    
    public boolean validateSignature(HttpServletRequest request, String apiKey) {
        String timestamp = request.getHeader("X-Timestamp");
        String nonce = request.getHeader("X-Nonce");
        String signature = request.getHeader("X-Signature");
        
        // 1. éªŒè¯æ—¶é—´æˆ³(é˜²é‡æ”¾æ”»å‡»)
        if (!isValidTimestamp(timestamp)) {
            return false;
        }
        
        // 2. éªŒè¯nonce(é˜²é‡å¤è¯·æ±‚)
        if (!isValidNonce(nonce)) {
            return false;
        }
        
        // 3. è®¡ç®—ç­¾å
        String body = getRequestBody(request);
        String expectedSignature = calculateSignature(apiKey, timestamp, nonce, body);
        
        // 4. éªŒè¯ç­¾å
        return signature.equals(expectedSignature);
    }
    
    private boolean isValidTimestamp(String timestamp) {
        try {
            long ts = Long.parseLong(timestamp);
            long now = System.currentTimeMillis() / 1000;
            // å…è®¸5åˆ†é’Ÿæ—¶é—´å·®
            return Math.abs(now - ts) <= 300;
        } catch (NumberFormatException e) {
            return false;
        }
    }
    
    private boolean isValidNonce(String nonce) {
        String key = "api:nonce:" + nonce;
        Boolean exists = redisTemplate.hasKey(key);
        if (exists) {
            return false; // nonceå·²ä½¿ç”¨
        }
        
        // è®°å½•nonceï¼Œ5åˆ†é’Ÿè¿‡æœŸ
        redisTemplate.opsForValue().set(key, "1", Duration.ofMinutes(5));
        return true;
    }
    
    private String calculateSignature(String apiKey, String timestamp, String nonce, String body) {
        String data = apiKey + timestamp + nonce + body;
        return DigestUtils.sha256Hex(data);
    }
}

// ç­¾åéªŒè¯æ‹¦æˆªå™¨
@Component
public class SignatureInterceptor implements HandlerInterceptor {
    
    @Autowired
    private ApiSignatureValidator signatureValidator;
    
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        // åªå¯¹APIæ¥å£è¿›è¡Œç­¾åéªŒè¯
        if (!request.getRequestURI().startsWith("/api/")) {
            return true;
        }
        
        String apiKey = request.getHeader("X-API-Key");
        if (StringUtils.isBlank(apiKey)) {
            response.setStatus(HttpStatus.UNAUTHORIZED.value());
            return false;
        }
        
        if (!signatureValidator.validateSignature(request, apiKey)) {
            response.setStatus(HttpStatus.UNAUTHORIZED.value());
            return false;
        }
        
        return true;
    }
}
```

### 2. é™æµé˜²æŠ¤
```java
// âœ… å¤šçº§é™æµç­–ç•¥
@Component
public class RateLimitService {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    /**
     * ä»¤ç‰Œæ¡¶é™æµ
     */
    public boolean allowRequest(String key, int maxRequests, Duration window) {
        String script = 
            "local key = KEYS[1] " +
            "local window = ARGV[1] " +
            "local limit = tonumber(ARGV[2]) " +
            "local current = redis.call('GET', key) " +
            "if current == false then " +
            "    redis.call('SET', key, 1) " +
            "    redis.call('EXPIRE', key, window) " +
            "    return 1 " +
            "end " +
            "if tonumber(current) < limit then " +
            "    return redis.call('INCR', key) " +
            "else " +
            "    return 0 " +
            "end";
        
        DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>(script, Long.class);
        Long result = redisTemplate.execute(redisScript, 
                                          Collections.singletonList(key), 
                                          String.valueOf(window.getSeconds()), 
                                          String.valueOf(maxRequests));
        return result != null && result > 0;
    }
    
    /**
     * æ»‘åŠ¨çª—å£é™æµ
     */
    public boolean allowRequestSlidingWindow(String key, int maxRequests, Duration window) {
        long now = System.currentTimeMillis();
        long windowStart = now - window.toMillis();
        
        String script =
            "local key = KEYS[1] " +
            "local window_start = ARGV[1] " +
            "local window_end = ARGV[2] " +
            "local limit = ARGV[3] " +
            "redis.call('ZREMRANGEBYSCORE', key, 0, window_start) " +
            "local current = redis.call('ZCARD', key) " +
            "if current < tonumber(limit) then " +
            "    redis.call('ZADD', key, window_end, window_end) " +
            "    redis.call('EXPIRE', key, 3600) " +
            "    return 1 " +
            "else " +
            "    return 0 " +
            "end";
        
        DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>(script, Long.class);
        Long result = redisTemplate.execute(redisScript,
                                          Collections.singletonList(key),
                                          String.valueOf(windowStart),
                                          String.valueOf(now),
                                          String.valueOf(maxRequests));
        return result != null && result > 0;
    }
}

// é™æµæ³¨è§£
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RateLimit {
    String key() default "";
    int maxRequests() default 100;
    int windowSeconds() default 60;
    RateLimitType type() default RateLimitType.TOKEN_BUCKET;
}

enum RateLimitType {
    TOKEN_BUCKET, SLIDING_WINDOW
}
```

## ğŸ›¡ï¸ è¾“å…¥éªŒè¯è§„åˆ™

### 1. å‚æ•°æ ¡éªŒ
```java
// âœ… å…¨é¢çš„å‚æ•°æ ¡éªŒ
@Data
@Valid
public class CreateAccountRequest {
    
    @NotBlank(message = "è´¦å·åç§°ä¸èƒ½ä¸ºç©º")
    @Length(min = 2, max = 50, message = "è´¦å·åç§°é•¿åº¦å¿…é¡»åœ¨2-50ä¹‹é—´")
    @Pattern(regexp = "^[a-zA-Z0-9\\u4e00-\\u9fa5_-]+$", message = "è´¦å·åç§°åªèƒ½åŒ…å«å­—æ¯ã€æ•°å­—ã€ä¸­æ–‡ã€ä¸‹åˆ’çº¿å’ŒçŸ­æ¨ªçº¿")
    private String accountName;
    
    @NotBlank(message = "ä¼å¾®GUIDä¸èƒ½ä¸ºç©º")
    @Pattern(regexp = "^[a-zA-Z0-9_-]{10,50}$", message = "ä¼å¾®GUIDæ ¼å¼ä¸æ­£ç¡®")
    private String weWorkGuid;
    
    @Email(message = "é‚®ç®±æ ¼å¼ä¸æ­£ç¡®")
    @Length(max = 100, message = "é‚®ç®±é•¿åº¦ä¸èƒ½è¶…è¿‡100")
    private String email;
    
    @Pattern(regexp = "^1[3-9]\\d{9}$", message = "æ‰‹æœºå·æ ¼å¼ä¸æ­£ç¡®")
    private String mobile;
    
    @Valid
    @NotNull(message = "é…ç½®ä¿¡æ¯ä¸èƒ½ä¸ºç©º")
    private AccountConfigDTO config;
}

// è‡ªå®šä¹‰æ ¡éªŒæ³¨è§£
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = TenantIdValidator.class)
public @interface ValidTenantId {
    String message() default "ç§Ÿæˆ·IDæ ¼å¼ä¸æ­£ç¡®";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

@Component
public class TenantIdValidator implements ConstraintValidator<ValidTenantId, String> {
    
    @Override
    public boolean isValid(String tenantId, ConstraintValidatorContext context) {
        if (StringUtils.isBlank(tenantId)) {
            return false;
        }
        
        // éªŒè¯UUIDæ ¼å¼
        try {
            UUID.fromString(tenantId);
            return true;
        } catch (IllegalArgumentException e) {
            return false;
        }
    }
}
```

### 2. XSSé˜²æŠ¤
```java
// âœ… XSSè¿‡æ»¤å™¨
@Component
public class XssFilter implements Filter {
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) 
            throws IOException, ServletException {
        
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        XssHttpServletRequestWrapper wrappedRequest = new XssHttpServletRequestWrapper(httpRequest);
        
        chain.doFilter(wrappedRequest, response);
    }
}

public class XssHttpServletRequestWrapper extends HttpServletRequestWrapper {
    
    private final Pattern[] xssPatterns = {
        Pattern.compile("<script[^>]*>.*?</script>", Pattern.CASE_INSENSITIVE),
        Pattern.compile("javascript:", Pattern.CASE_INSENSITIVE),
        Pattern.compile("onload=", Pattern.CASE_INSENSITIVE),
        Pattern.compile("onclick=", Pattern.CASE_INSENSITIVE),
        Pattern.compile("onerror=", Pattern.CASE_INSENSITIVE)
    };
    
    public XssHttpServletRequestWrapper(HttpServletRequest request) {
        super(request);
    }
    
    @Override
    public String getParameter(String name) {
        String value = super.getParameter(name);
        return cleanXss(value);
    }
    
    @Override
    public String[] getParameterValues(String name) {
        String[] values = super.getParameterValues(name);
        if (values != null) {
            for (int i = 0; i < values.length; i++) {
                values[i] = cleanXss(values[i]);
            }
        }
        return values;
    }
    
    private String cleanXss(String value) {
        if (value == null) {
            return null;
        }
        
        String cleanValue = value;
        for (Pattern pattern : xssPatterns) {
            cleanValue = pattern.matcher(cleanValue).replaceAll("");
        }
        
        return StringEscapeUtils.escapeHtml4(cleanValue);
    }
}
```

**è§„åˆ™æ€»ç»“**:
- ä½¿ç”¨JWTè¿›è¡Œèº«ä»½è®¤è¯ï¼Œå®ç°æ— çŠ¶æ€è®¤è¯
- åŸºäºRBACæ¨¡å‹å®ç°ç»†ç²’åº¦æƒé™æ§åˆ¶
- æ•æ„Ÿæ•°æ®å¿…é¡»åŠ å¯†å­˜å‚¨ï¼Œä¼ è¾“ä½¿ç”¨HTTPS
- APIæ¥å£å®ç°ç­¾åéªŒè¯å’Œé™æµä¿æŠ¤
- ä¸¥æ ¼è¿›è¡Œè¾“å…¥éªŒè¯ï¼Œé˜²æ­¢XSSå’ŒSQLæ³¨å…¥
- è®°å½•è¯¦ç»†çš„å®‰å…¨å®¡è®¡æ—¥å¿—# ğŸ” å®‰å…¨è®¾è®¡å’Œå®ç°è§„åˆ™

## ğŸ›¡ï¸ è®¤è¯æˆæƒè§„åˆ™

### 1. JWT Tokenç®¡ç†
```java
// âœ… JWTå·¥å…·ç±»å®ç°
@Component
@ConfigurationProperties(prefix = "app.jwt")
@Data
public class JwtUtils {
    
    private String secretKey = "default-secret-key-change-in-production";
    private long accessTokenExpiration = 7200000; // 2å°æ—¶
    private long refreshTokenExpiration = 604800000; // 7å¤©
    private String issuer = "wework-platform";
    
    private final Algorithm algorithm = Algorithm.HMAC256(secretKey);
    
    public String generateAccessToken(UserContext userContext) {
        return JWT.create()
                .withIssuer(issuer)
                .withSubject(userContext.getUserId())
                .withClaim("tenantId", userContext.getTenantId())
                .withClaim("username", userContext.getUsername())
                .withClaim("roles", userContext.getRoles())
                .withClaim("permissions", userContext.getPermissions())
                .withClaim("tokenType", "access")
                .withIssuedAt(new Date())
                .withExpiresAt(new Date(System.currentTimeMillis() + accessTokenExpiration))
                .sign(algorithm);
    }
    
    public String generateRefreshToken(String userId) {
        return JWT.create()
                .withIssuer(issuer)
                .withSubject(userId)
                .withClaim("tokenType", "refresh")
                .withIssuedAt(new Date())
                .withExpiresAt(new Date(System.currentTimeMillis() + refreshTokenExpiration))
                .sign(algorithm);
    }
    
    public boolean validateToken(String token) {
        try {
            JWTVerifier verifier = JWT.require(algorithm)
                    .withIssuer(issuer)
                    .build();
            verifier.verify(token);
            return true;
        } catch (JWTVerificationException e) {
            log.warn("TokenéªŒè¯å¤±è´¥: {}", e.getMessage());
            return false;
        }
    }
    
    public UserContext parseToken(String token) {
        try {
            DecodedJWT jwt = JWT.decode(token);
            return UserContext.builder()
                    .userId(jwt.getSubject())
                    .tenantId(jwt.getClaim("tenantId").asString())
                    .username(jwt.getClaim("username").asString())
                    .roles(jwt.getClaim("roles").asList(String.class))
                    .permissions(jwt.getClaim("permissions").asList(String.class))
                    .build();
        } catch (Exception e) {
            throw new SecurityException("Tokenè§£æå¤±è´¥", e);
        }
    }
}
```

### 2. æƒé™æ§åˆ¶å®ç°
```java
// âœ… åŸºäºæ³¨è§£çš„æƒé™æ§åˆ¶
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RequirePermission {
    String resource();
    String action();
}

@Component
@RequiredArgsConstructor
public class PermissionService {
    
    private final RedisTemplate<String, Object> redisTemplate;
    
    public boolean hasPermission(String userId, String tenantId, String resource, String action) {
        // 1. ä»ç¼“å­˜è·å–ç”¨æˆ·æƒé™
        String cacheKey = String.format("user:permissions:%s:%s", tenantId, userId);
        Set<String> permissions = (Set<String>) redisTemplate.opsForValue().get(cacheKey);
        
        if (permissions == null) {
            // 2. ä»æ•°æ®åº“åŠ è½½æƒé™
            permissions = loadUserPermissions(userId, tenantId);
            // 3. ç¼“å­˜æƒé™(30åˆ†é’Ÿ)
            redisTemplate.opsForValue().set(cacheKey, permissions, Duration.ofMinutes(30));
        }
        
        // 4. æ£€æŸ¥æƒé™
        String permission = resource + ":" + action;
        return permissions.contains(permission) || permissions.contains("*:*");
    }
    
    private Set<String> loadUserPermissions(String userId, String tenantId) {
        // æŸ¥è¯¢ç”¨æˆ·è§’è‰²
        List<String> roles = userRoleMapper.selectRolesByUserId(userId, tenantId);
        
        // æŸ¥è¯¢è§’è‰²æƒé™
        Set<String> permissions = new HashSet<>();
        for (String role : roles) {
            List<String> rolePermissions = rolePermissionMapper.selectPermissionsByRole(role, tenantId);
            permissions.addAll(rolePermissions);
        }
        
        return permissions;
    }
}

// AOPæƒé™æ‹¦æˆªå™¨
@Aspect
@Component
@RequiredArgsConstructor
public class PermissionAspect {
    
    private final PermissionService permissionService;
    
    @Around("@annotation(requirePermission)")
    public Object checkPermission(ProceedingJoinPoint point, RequirePermission requirePermission) throws Throwable {
        UserContext userContext = UserContextHolder.getContext();
        if (userContext == null) {
            throw new SecurityException("ç”¨æˆ·æœªç™»å½•");
        }
        
        boolean hasPermission = permissionService.hasPermission(
                userContext.getUserId(),
                userContext.getTenantId(),
                requirePermission.resource(),
                requirePermission.action()
        );
        
        if (!hasPermission) {
            throw new BusinessException(ErrorCode.FORBIDDEN, 
                    String.format("æ— æƒé™æ‰§è¡Œæ“ä½œ: %s:%s", 
                                 requirePermission.resource(), 
                                 requirePermission.action()));
        }
        
        return point.proceed();
    }
}
```

## ğŸ”’ æ•°æ®å®‰å…¨è§„åˆ™

### 1. æ•æ„Ÿæ•°æ®åŠ å¯†
```java
// âœ… æ•°æ®åŠ å¯†å·¥å…·
@Component
public class CryptoUtils {
    
    private static final String AES_ALGORITHM = "AES/CBC/PKCS5Padding";
    private static final String KEY_ALGORITHM = "AES";
    private static final int KEY_LENGTH = 256;
    
    @Value("${app.security.encrypt.key}")
    private String encryptKey;
    
    public String encrypt(String plainText) {
        if (StringUtils.isBlank(plainText)) {
            return plainText;
        }
        
        try {
            SecretKeySpec keySpec = new SecretKeySpec(encryptKey.getBytes(), KEY_ALGORITHM);
            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);
            
            // ç”ŸæˆéšæœºIV
            byte[] iv = new byte[16];
            new SecureRandom().nextBytes(iv);
            IvParameterSpec ivSpec = new IvParameterSpec(iv);
            
            cipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);
            byte[] encrypted = cipher.doFinal(plainText.getBytes(StandardCharsets.UTF_8));
            
            // IV + åŠ å¯†æ•°æ®
            byte[] result = new byte[iv.length + encrypted.length];
            System.arraycopy(iv, 0, result, 0, iv.length);
            System.arraycopy(encrypted, 0, result, iv.length, encrypted.length);
            
            return Base64.getEncoder().encodeToString(result);
            
        } catch (Exception e) {
            throw new SecurityException("æ•°æ®åŠ å¯†å¤±è´¥", e);
        }
    }
    
    public String decrypt(String encryptedText) {
        if (StringUtils.isBlank(encryptedText)) {
            return encryptedText;
        }
        
        try {
            byte[] data = Base64.getDecoder().decode(encryptedText);
            
            // æå–IV
            byte[] iv = new byte[16];
            System.arraycopy(data, 0, iv, 0, 16);
            
            // æå–åŠ å¯†æ•°æ®
            byte[] encrypted = new byte[data.length - 16];
            System.arraycopy(data, 16, encrypted, 0, encrypted.length);
            
            SecretKeySpec keySpec = new SecretKeySpec(encryptKey.getBytes(), KEY_ALGORITHM);
            Cipher cipher = Cipher.getInstance(AES_ALGORITHM);
            IvParameterSpec ivSpec = new IvParameterSpec(iv);
            
            cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);
            byte[] decrypted = cipher.doFinal(encrypted);
            
            return new String(decrypted, StandardCharsets.UTF_8);
            
        } catch (Exception e) {
            throw new SecurityException("æ•°æ®è§£å¯†å¤±è´¥", e);
        }
    }
}

// æ•æ„Ÿå­—æ®µè‡ªåŠ¨åŠ å¯†
@Component
public class SensitiveDataHandler implements TypeHandler<String> {
    
    @Autowired
    private CryptoUtils cryptoUtils;
    
    @Override
    public void setParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException {
        if (parameter != null) {
            ps.setString(i, cryptoUtils.encrypt(parameter));
        } else {
            ps.setString(i, null);
        }
    }
    
    @Override
    public String getResult(ResultSet rs, String columnName) throws SQLException {
        String encrypted = rs.getString(columnName);
        return encrypted != null ? cryptoUtils.decrypt(encrypted) : null;
    }
}
```

### 2. SQLæ³¨å…¥é˜²æŠ¤
```java
// âœ… é˜²SQLæ³¨å…¥è§„èŒƒ
@Repository
public class AccountMapper {
    
    // æ­£ç¡®ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢
    @Select("SELECT * FROM wework_accounts WHERE tenant_id = #{tenantId} AND account_name = #{accountName}")
    WeWorkAccount selectByTenantAndName(@Param("tenantId") String tenantId, 
                                       @Param("accountName") String accountName);
    
    // åŠ¨æ€SQLä½¿ç”¨#{}å‚æ•°ç»‘å®š
    List<WeWorkAccount> selectByConditions(AccountQueryDTO query) {
        return sqlSession.selectList("selectByConditions", query);
    }
    
    // âŒ é”™è¯¯ï¼šå­—ç¬¦ä¸²æ‹¼æ¥å®¹æ˜“SQLæ³¨å…¥
    // String sql = "SELECT * FROM accounts WHERE name = '" + name + "'";
}

// MyBatisåŠ¨æ€SQL
@Mapper
public interface AccountMapper {
    
    List<WeWorkAccount> selectByDynamicConditions(@Param("query") AccountQueryDTO query);
}

<!-- account-mapper.xml -->
<select id="selectByDynamicConditions" resultType="WeWorkAccount">
    SELECT * FROM wework_accounts 
    WHERE tenant_id = #{query.tenantId}
    <if test="query.accountName != null and query.accountName != ''">
        AND account_name LIKE CONCAT('%', #{query.accountName}, '%')
    </if>
    <if test="query.status != null">
        AND status = #{query.status}
    </if>
    <if test="query.startDate != null">
        AND created_at >= #{query.startDate}
    </if>
    ORDER BY created_at DESC
    LIMIT #{query.offset}, #{query.limit}
</select>
```

## ğŸ” APIå®‰å…¨è§„åˆ™

### 1. è¯·æ±‚ç­¾åéªŒè¯
```java
// âœ… APIç­¾åéªŒè¯
@Component
public class ApiSignatureValidator {
    
    public boolean validateSignature(HttpServletRequest request, String apiKey) {
        String timestamp = request.getHeader("X-Timestamp");
        String nonce = request.getHeader("X-Nonce");
        String signature = request.getHeader("X-Signature");
        
        // 1. éªŒè¯æ—¶é—´æˆ³(é˜²é‡æ”¾æ”»å‡»)
        if (!isValidTimestamp(timestamp)) {
            return false;
        }
        
        // 2. éªŒè¯nonce(é˜²é‡å¤è¯·æ±‚)
        if (!isValidNonce(nonce)) {
            return false;
        }
        
        // 3. è®¡ç®—ç­¾å
        String body = getRequestBody(request);
        String expectedSignature = calculateSignature(apiKey, timestamp, nonce, body);
        
        // 4. éªŒè¯ç­¾å
        return signature.equals(expectedSignature);
    }
    
    private boolean isValidTimestamp(String timestamp) {
        try {
            long ts = Long.parseLong(timestamp);
            long now = System.currentTimeMillis() / 1000;
            // å…è®¸5åˆ†é’Ÿæ—¶é—´å·®
            return Math.abs(now - ts) <= 300;
        } catch (NumberFormatException e) {
            return false;
        }
    }
    
    private boolean isValidNonce(String nonce) {
        String key = "api:nonce:" + nonce;
        Boolean exists = redisTemplate.hasKey(key);
        if (exists) {
            return false; // nonceå·²ä½¿ç”¨
        }
        
        // è®°å½•nonceï¼Œ5åˆ†é’Ÿè¿‡æœŸ
        redisTemplate.opsForValue().set(key, "1", Duration.ofMinutes(5));
        return true;
    }
    
    private String calculateSignature(String apiKey, String timestamp, String nonce, String body) {
        String data = apiKey + timestamp + nonce + body;
        return DigestUtils.sha256Hex(data);
    }
}

// ç­¾åéªŒè¯æ‹¦æˆªå™¨
@Component
public class SignatureInterceptor implements HandlerInterceptor {
    
    @Autowired
    private ApiSignatureValidator signatureValidator;
    
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        // åªå¯¹APIæ¥å£è¿›è¡Œç­¾åéªŒè¯
        if (!request.getRequestURI().startsWith("/api/")) {
            return true;
        }
        
        String apiKey = request.getHeader("X-API-Key");
        if (StringUtils.isBlank(apiKey)) {
            response.setStatus(HttpStatus.UNAUTHORIZED.value());
            return false;
        }
        
        if (!signatureValidator.validateSignature(request, apiKey)) {
            response.setStatus(HttpStatus.UNAUTHORIZED.value());
            return false;
        }
        
        return true;
    }
}
```

### 2. é™æµé˜²æŠ¤
```java
// âœ… å¤šçº§é™æµç­–ç•¥
@Component
public class RateLimitService {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    /**
     * ä»¤ç‰Œæ¡¶é™æµ
     */
    public boolean allowRequest(String key, int maxRequests, Duration window) {
        String script = 
            "local key = KEYS[1] " +
            "local window = ARGV[1] " +
            "local limit = tonumber(ARGV[2]) " +
            "local current = redis.call('GET', key) " +
            "if current == false then " +
            "    redis.call('SET', key, 1) " +
            "    redis.call('EXPIRE', key, window) " +
            "    return 1 " +
            "end " +
            "if tonumber(current) < limit then " +
            "    return redis.call('INCR', key) " +
            "else " +
            "    return 0 " +
            "end";
        
        DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>(script, Long.class);
        Long result = redisTemplate.execute(redisScript, 
                                          Collections.singletonList(key), 
                                          String.valueOf(window.getSeconds()), 
                                          String.valueOf(maxRequests));
        return result != null && result > 0;
    }
    
    /**
     * æ»‘åŠ¨çª—å£é™æµ
     */
    public boolean allowRequestSlidingWindow(String key, int maxRequests, Duration window) {
        long now = System.currentTimeMillis();
        long windowStart = now - window.toMillis();
        
        String script =
            "local key = KEYS[1] " +
            "local window_start = ARGV[1] " +
            "local window_end = ARGV[2] " +
            "local limit = ARGV[3] " +
            "redis.call('ZREMRANGEBYSCORE', key, 0, window_start) " +
            "local current = redis.call('ZCARD', key) " +
            "if current < tonumber(limit) then " +
            "    redis.call('ZADD', key, window_end, window_end) " +
            "    redis.call('EXPIRE', key, 3600) " +
            "    return 1 " +
            "else " +
            "    return 0 " +
            "end";
        
        DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>(script, Long.class);
        Long result = redisTemplate.execute(redisScript,
                                          Collections.singletonList(key),
                                          String.valueOf(windowStart),
                                          String.valueOf(now),
                                          String.valueOf(maxRequests));
        return result != null && result > 0;
    }
}

// é™æµæ³¨è§£
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RateLimit {
    String key() default "";
    int maxRequests() default 100;
    int windowSeconds() default 60;
    RateLimitType type() default RateLimitType.TOKEN_BUCKET;
}

enum RateLimitType {
    TOKEN_BUCKET, SLIDING_WINDOW
}
```

## ğŸ›¡ï¸ è¾“å…¥éªŒè¯è§„åˆ™

### 1. å‚æ•°æ ¡éªŒ
```java
// âœ… å…¨é¢çš„å‚æ•°æ ¡éªŒ
@Data
@Valid
public class CreateAccountRequest {
    
    @NotBlank(message = "è´¦å·åç§°ä¸èƒ½ä¸ºç©º")
    @Length(min = 2, max = 50, message = "è´¦å·åç§°é•¿åº¦å¿…é¡»åœ¨2-50ä¹‹é—´")
    @Pattern(regexp = "^[a-zA-Z0-9\\u4e00-\\u9fa5_-]+$", message = "è´¦å·åç§°åªèƒ½åŒ…å«å­—æ¯ã€æ•°å­—ã€ä¸­æ–‡ã€ä¸‹åˆ’çº¿å’ŒçŸ­æ¨ªçº¿")
    private String accountName;
    
    @NotBlank(message = "ä¼å¾®GUIDä¸èƒ½ä¸ºç©º")
    @Pattern(regexp = "^[a-zA-Z0-9_-]{10,50}$", message = "ä¼å¾®GUIDæ ¼å¼ä¸æ­£ç¡®")
    private String weWorkGuid;
    
    @Email(message = "é‚®ç®±æ ¼å¼ä¸æ­£ç¡®")
    @Length(max = 100, message = "é‚®ç®±é•¿åº¦ä¸èƒ½è¶…è¿‡100")
    private String email;
    
    @Pattern(regexp = "^1[3-9]\\d{9}$", message = "æ‰‹æœºå·æ ¼å¼ä¸æ­£ç¡®")
    private String mobile;
    
    @Valid
    @NotNull(message = "é…ç½®ä¿¡æ¯ä¸èƒ½ä¸ºç©º")
    private AccountConfigDTO config;
}

// è‡ªå®šä¹‰æ ¡éªŒæ³¨è§£
@Target({ElementType.FIELD, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = TenantIdValidator.class)
public @interface ValidTenantId {
    String message() default "ç§Ÿæˆ·IDæ ¼å¼ä¸æ­£ç¡®";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}

@Component
public class TenantIdValidator implements ConstraintValidator<ValidTenantId, String> {
    
    @Override
    public boolean isValid(String tenantId, ConstraintValidatorContext context) {
        if (StringUtils.isBlank(tenantId)) {
            return false;
        }
        
        // éªŒè¯UUIDæ ¼å¼
        try {
            UUID.fromString(tenantId);
            return true;
        } catch (IllegalArgumentException e) {
            return false;
        }
    }
}
```

### 2. XSSé˜²æŠ¤
```java
// âœ… XSSè¿‡æ»¤å™¨
@Component
public class XssFilter implements Filter {
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) 
            throws IOException, ServletException {
        
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        XssHttpServletRequestWrapper wrappedRequest = new XssHttpServletRequestWrapper(httpRequest);
        
        chain.doFilter(wrappedRequest, response);
    }
}

public class XssHttpServletRequestWrapper extends HttpServletRequestWrapper {
    
    private final Pattern[] xssPatterns = {
        Pattern.compile("<script[^>]*>.*?</script>", Pattern.CASE_INSENSITIVE),
        Pattern.compile("javascript:", Pattern.CASE_INSENSITIVE),
        Pattern.compile("onload=", Pattern.CASE_INSENSITIVE),
        Pattern.compile("onclick=", Pattern.CASE_INSENSITIVE),
        Pattern.compile("onerror=", Pattern.CASE_INSENSITIVE)
    };
    
    public XssHttpServletRequestWrapper(HttpServletRequest request) {
        super(request);
    }
    
    @Override
    public String getParameter(String name) {
        String value = super.getParameter(name);
        return cleanXss(value);
    }
    
    @Override
    public String[] getParameterValues(String name) {
        String[] values = super.getParameterValues(name);
        if (values != null) {
            for (int i = 0; i < values.length; i++) {
                values[i] = cleanXss(values[i]);
            }
        }
        return values;
    }
    
    private String cleanXss(String value) {
        if (value == null) {
            return null;
        }
        
        String cleanValue = value;
        for (Pattern pattern : xssPatterns) {
            cleanValue = pattern.matcher(cleanValue).replaceAll("");
        }
        
        return StringEscapeUtils.escapeHtml4(cleanValue);
    }
}
```

**è§„åˆ™æ€»ç»“**:
- ä½¿ç”¨JWTè¿›è¡Œèº«ä»½è®¤è¯ï¼Œå®ç°æ— çŠ¶æ€è®¤è¯
- åŸºäºRBACæ¨¡å‹å®ç°ç»†ç²’åº¦æƒé™æ§åˆ¶
- æ•æ„Ÿæ•°æ®å¿…é¡»åŠ å¯†å­˜å‚¨ï¼Œä¼ è¾“ä½¿ç”¨HTTPS
- APIæ¥å£å®ç°ç­¾åéªŒè¯å’Œé™æµä¿æŠ¤
- ä¸¥æ ¼è¿›è¡Œè¾“å…¥éªŒè¯ï¼Œé˜²æ­¢XSSå’ŒSQLæ³¨å…¥
- è®°å½•è¯¦ç»†çš„å®‰å…¨å®¡è®¡æ—¥å¿—