---
alwaysApply: true
---

# 🔌 API设计和实现规则

## 📐 RESTful API设计规范

### 1. URL设计规则
```yaml
URL结构规范:
  基础格式: https://api.domain.com/api/v1/resource
  
  规则:
    - 使用小写字母和短横线分隔
    - 资源名使用复数形式
    - 避免动词，使用HTTP方法表示动作
    - 层级不超过3层
    
  正确示例:
    GET    /api/v1/accounts                    # 获取账号列表
    POST   /api/v1/accounts                    # 创建账号
    GET    /api/v1/accounts/{id}               # 获取单个账号
    PUT    /api/v1/accounts/{id}               # 更新账号
    DELETE /api/v1/accounts/{id}               # 删除账号
    GET    /api/v1/accounts/{id}/messages      # 获取账号的消息列表
    
  错误示例:
    GET    /api/v1/getAccount/{id}             # 包含动词
    POST   /api/v1/account                     # 资源名单数
    GET    /api/v1/Accounts                    # 大写字母
    GET    /api/v1/accounts_list               # 下划线分隔
```

### 2. HTTP方法使用规范
```yaml
HTTP方法规范:
  GET:    查询操作，幂等，无副作用
  POST:   创建操作，非幂等
  PUT:    更新操作(全量)，幂等
  PATCH:  更新操作(部分)，幂等
  DELETE: 删除操作，幂等
  
  状态码规范:
    2xx: 成功
      200: 成功(GET/PUT/PATCH)
      201: 创建成功(POST)
      204: 删除成功(DELETE)
    4xx: 客户端错误
      400: 请求参数错误
      401: 未认证
      403: 无权限
      404: 资源不存在
      409: 资源冲突
    5xx: 服务端错误
      500: 服务器内部错误
      503: 服务不可用
```

## 📨 统一响应格式

### 1. 成功响应格式
```java
// ✅ 正确的响应格式
@Data
public class Result<T> {
    private Integer code;
    private String message;
    private T data;
    private Long timestamp;
    private String requestId;
    
    public static <T> Result<T> success(T data) {
        Result<T> result = new Result<>();
        result.setCode(200);
        result.setMessage("success");
        result.setData(data);
        result.setTimestamp(System.currentTimeMillis());
        result.setRequestId(MDC.get("requestId"));
        return result;
    }
}

// 控制器中的使用
@RestController
@RequestMapping("/api/v1/accounts")
public class AccountController {
    
    @GetMapping("/{id}")
    public Result<AccountDTO> getAccount(@PathVariable String id) {
        AccountDTO account = accountService.getAccount(getCurrentTenantId(), id);
        return Result.success(account);
    }
    
    @GetMapping
    public Result<PageResult<AccountDTO>> getAccounts(
            @RequestParam(defaultValue = "1") Integer pageNum,
            @RequestParam(defaultValue = "20") Integer pageSize) {
        PageResult<AccountDTO> pageResult = accountService.getAccounts(
            getCurrentTenantId(), pageNum, pageSize);
        return Result.success(pageResult);
    }
}
```

### 2. 错误响应格式
```java
// ✅ 统一异常处理
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(ValidationException.class)
    public Result<Void> handleValidationException(ValidationException e) {
        return Result.error(ErrorCode.PARAM_ERROR, e.getMessage());
    }
    
    @ExceptionHandler(BusinessException.class)
    public Result<Void> handleBusinessException(BusinessException e) {
        return Result.error(e.getErrorCode(), e.getMessage());
    }
    
    @ExceptionHandler(Exception.class)
    public Result<Void> handleException(Exception e) {
        log.error("系统异常", e);
        return Result.error(ErrorCode.SYSTEM_ERROR, "系统异常，请稍后重试");
    }
}

// 错误码定义
public enum ErrorCode {
    SUCCESS(200, "操作成功"),
    PARAM_ERROR(400, "参数错误"),
    UNAUTHORIZED(401, "未登录"),
    FORBIDDEN(403, "无权限"),
    NOT_FOUND(404, "资源不存在"),
    CONFLICT(409, "资源冲突"),
    SYSTEM_ERROR(500, "系统错误"),
    
    // 业务错误码
    ACCOUNT_NOT_FOUND(40001, "账号不存在"),
    ACCOUNT_QUOTA_EXCEEDED(40002, "账号配额已满"),
    MESSAGE_SEND_FAILED(40003, "消息发送失败");
    
    private final Integer code;
    private final String message;
}
```

## 🔐 认证授权规则

### 1. JWT Token处理
```java
// ✅ 正确的认证实现
@Component
public class JwtAuthenticationFilter implements Filter {
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, 
                        FilterChain chain) throws IOException, ServletException {
        
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        String token = getTokenFromRequest(httpRequest);
        
        if (StringUtils.hasText(token) && jwtUtils.validateToken(token)) {
            // 解析用户信息
            UserContext userContext = jwtUtils.parseToken(token);
            
            // 设置上下文
            UserContextHolder.setContext(userContext);
            
            // 设置请求ID
            String requestId = UUID.randomUUID().toString();
            MDC.put("requestId", requestId);
            MDC.put("tenantId", userContext.getTenantId());
            MDC.put("userId", userContext.getUserId());
        }
        
        try {
            chain.doFilter(request, response);
        } finally {
            // 清理上下文
            UserContextHolder.clear();
            MDC.clear();
        }
    }
    
    private String getTokenFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}

// 用户上下文
@Data
public class UserContext {
    private String userId;
    private String tenantId;
    private String username;
    private List<String> roles;
    private List<String> permissions;
}
```

### 2. 权限控制
```java
// ✅ 方法级权限控制
@RestController
@RequestMapping("/api/v1/accounts")
public class AccountController {
    
    @GetMapping("/{id}")
    @PreAuthorize("hasPermission('account', 'read')")
    public Result<AccountDTO> getAccount(@PathVariable String id) {
        return Result.success(accountService.getAccount(getCurrentTenantId(), id));
    }
    
    @PostMapping
    @PreAuthorize("hasPermission('account', 'create')")
    public Result<AccountDTO> createAccount(@Valid @RequestBody CreateAccountRequest request) {
        AccountDTO account = accountService.createAccount(getCurrentTenantId(), request);
        return Result.success(account);
    }
    
    @DeleteMapping("/{id}")
    @PreAuthorize("hasPermission('account', 'delete')")
    public Result<Void> deleteAccount(@PathVariable String id) {
        accountService.deleteAccount(getCurrentTenantId(), id);
        return Result.success();
    }
    
    private String getCurrentTenantId() {
        return UserContextHolder.getContext().getTenantId();
    }
}
```

## 📋 参数验证规则

### 1. 请求参数验证
```java
// ✅ 正确的参数验证
@Data
@Valid
public class CreateAccountRequest {
    
    @NotBlank(message = "账号名称不能为空")
    @Length(min = 2, max = 50, message = "账号名称长度必须在2-50之间")
    private String accountName;
    
    @NotBlank(message = "企微GUID不能为空")
    @Pattern(regexp = "^[a-zA-Z0-9_-]+$", message = "企微GUID格式不正确")
    private String weWorkGuid;
    
    @Email(message = "邮箱格式不正确")
    private String email;
    
    @NotNull(message = "配置信息不能为空")
    @Valid
    private AccountConfigDTO config;
    
    @JsonProperty("account_name")
    public String getAccountName() {
        return accountName;
    }
}

@Data
public class AccountConfigDTO {
    
    @NotNull(message = "最大联系人数量不能为空")
    @Min(value = 1, message = "最大联系人数量不能小于1")
    @Max(value = 10000, message = "最大联系人数量不能大于10000")
    private Integer maxContacts;
    
    @NotNull(message = "是否启用自动回复不能为空")
    private Boolean autoReplyEnabled;
}
```

### 2. 分页参数处理
```java
// ✅ 统一分页处理
@Data
public class PageQuery {
    
    @Min(value = 1, message = "页码不能小于1")
    private Integer pageNum = 1;
    
    @Min(value = 1, message = "页大小不能小于1")
    @Max(value = 100, message = "页大小不能大于100")
    private Integer pageSize = 20;
    
    private String sortBy;
    
    @Pattern(regexp = "^(asc|desc)$", message = "排序方向只能是asc或desc")
    private String sortOrder = "desc";
}

@Data
public class PageResult<T> {
    private List<T> records;
    private Long total;
    private Integer pageNum;
    private Integer pageSize;
    private Integer pages;
    
    public static <T> PageResult<T> of(List<T> records, Long total, 
                                      Integer pageNum, Integer pageSize) {
        PageResult<T> result = new PageResult<>();
        result.setRecords(records);
        result.setTotal(total);
        result.setPageNum(pageNum);
        result.setPageSize(pageSize);
        result.setPages((int) Math.ceil((double) total / pageSize));
        return result;
    }
}
```

## 🔄 异步处理规则

### 1. 异步接口设计
```java
// ✅ 异步任务处理
@RestController
@RequestMapping("/api/v1/messages")
public class MessageController {
    
    @PostMapping("/batch-send")
    public Result<String> batchSendMessages(@Valid @RequestBody BatchSendRequest request) {
        // 创建异步任务
        String taskId = messageService.createBatchSendTask(getCurrentTenantId(), request);
        return Result.success(taskId);
    }
    
    @GetMapping("/tasks/{taskId}")
    public Result<TaskStatusDTO> getTaskStatus(@PathVariable String taskId) {
        TaskStatusDTO status = messageService.getTaskStatus(getCurrentTenantId(), taskId);
        return Result.success(status);
    }
}

@Service
public class MessageService {
    
    @Async("taskExecutor")
    public CompletableFuture<Void> processBatchSendTask(String tenantId, String taskId, 
                                                       BatchSendRequest request) {
        try {
            // 更新任务状态为进行中
            taskService.updateTaskStatus(taskId, TaskStatus.RUNNING);
            
            // 执行批量发送
            List<String> messageIds = batchSendMessages(tenantId, request);
            
            // 更新任务状态为完成
            taskService.updateTaskStatus(taskId, TaskStatus.COMPLETED, messageIds);
            
        } catch (Exception e) {
            // 更新任务状态为失败
            taskService.updateTaskStatus(taskId, TaskStatus.FAILED, e.getMessage());
            throw e;
        }
        return CompletableFuture.completedFuture(null);
    }
}
```

### 2. 回调处理
```java
// ✅ 回调接口设计
@RestController
@RequestMapping("/api/v1/callbacks")
public class CallbackController {
    
    @PostMapping("/wework/message-status")
    public Result<Void> handleMessageStatusCallback(@RequestBody MessageStatusCallback callback,
                                                   HttpServletRequest request) {
        // 验证回调签名
        if (!callbackService.verifySignature(request, callback)) {
            throw new BusinessException(ErrorCode.INVALID_SIGNATURE);
        }
        
        // 异步处理回调
        callbackService.processMessageStatusCallback(callback);
        
        return Result.success();
    }
}

@Component
public class CallbackService {
    
    @Async("callbackExecutor")
    public void processMessageStatusCallback(MessageStatusCallback callback) {
        try {
            // 更新消息状态
            messageService.updateMessageStatus(callback.getMessageId(), 
                                             callback.getStatus());
            
            // 发送状态变更事件
            eventPublisher.publishMessageStatusChanged(callback);
            
        } catch (Exception e) {
            log.error("处理消息状态回调失败", e);
            // 可以考虑重试机制
        }
    }
    
    public boolean verifySignature(HttpServletRequest request, Object callback) {
        String signature = request.getHeader("X-Signature");
        String timestamp = request.getHeader("X-Timestamp");
        
        // 验证时间戳(防重放攻击)
        if (Math.abs(System.currentTimeMillis() - Long.parseLong(timestamp)) > 300000) {
            return false;
        }
        
        // 验证签名
        String expectedSignature = calculateSignature(callback, timestamp);
        return signature.equals(expectedSignature);
    }
}
```

## 📊 API监控规则

### 1. 接口监控
```java
// ✅ 接口性能监控
@Aspect
@Component
public class ApiMonitorAspect {
    
    private final MeterRegistry meterRegistry;
    
    @Around("@annotation(org.springframework.web.bind.annotation.RequestMapping) || " +
            "@annotation(org.springframework.web.bind.annotation.GetMapping) || " +
            "@annotation(org.springframework.web.bind.annotation.PostMapping)")
    public Object monitorApi(ProceedingJoinPoint point) throws Throwable {
        String methodName = point.getSignature().getName();
        String className = point.getTarget().getClass().getSimpleName();
        String apiName = className + "." + methodName;
        
        Timer.Sample sample = Timer.start(meterRegistry);
        
        try {
            Object result = point.proceed();
            
            // 记录成功指标
            meterRegistry.counter("api.requests.total", 
                                "api", apiName, "status", "success").increment();
            
            return result;
            
        } catch (Exception e) {
            // 记录失败指标
            meterRegistry.counter("api.requests.total", 
                                "api", apiName, "status", "error").increment();
            throw e;
            
        } finally {
            // 记录响应时间
            sample.stop(Timer.builder("api.response.time")
                           .tag("api", apiName)
                           .register(meterRegistry));
        }
    }
}
```

### 2. 限流配置
```java
// ✅ 接口限流
@RestController
@RequestMapping("/api/v1/accounts")
public class AccountController {
    
    @GetMapping
    @RateLimiter(name = "account-query", fallbackMethod = "getAccountsFallback")
    public Result<PageResult<AccountDTO>> getAccounts(PageQuery query) {
        PageResult<AccountDTO> result = accountService.getAccounts(
            getCurrentTenantId(), query);
        return Result.success(result);
    }
    
    @PostMapping
    @RateLimiter(name = "account-create", fallbackMethod = "createAccountFallback")
    public Result<AccountDTO> createAccount(@Valid @RequestBody CreateAccountRequest request) {
        AccountDTO account = accountService.createAccount(getCurrentTenantId(), request);
        return Result.success(account);
    }
    
    // 降级方法
    public Result<PageResult<AccountDTO>> getAccountsFallback(PageQuery query, Exception e) {
        log.warn("账号查询接口限流，返回空结果");
        return Result.success(PageResult.empty());
    }
    
    public Result<AccountDTO> createAccountFallback(CreateAccountRequest request, Exception e) {
        log.warn("账号创建接口限流");
        throw new BusinessException(ErrorCode.RATE_LIMIT_EXCEEDED, "请求过于频繁，请稍后重试");
    }
}
```

**规则总结**:
- 所有API必须遵循RESTful设计规范
- 统一使用Result包装响应数据
- 必须进行参数验证和权限控制
- 异步操作需要提供任务状态查询接口
- 重要接口必须配置限流和监控
- 回调接口需要验证签名和防重放攻击# 🔌 API设计和实现规则

## 📐 RESTful API设计规范

### 1. URL设计规则
```yaml
URL结构规范:
  基础格式: https://api.domain.com/api/v1/resource
  
  规则:
    - 使用小写字母和短横线分隔
    - 资源名使用复数形式
    - 避免动词，使用HTTP方法表示动作
    - 层级不超过3层
    
  正确示例:
    GET    /api/v1/accounts                    # 获取账号列表
    POST   /api/v1/accounts                    # 创建账号
    GET    /api/v1/accounts/{id}               # 获取单个账号
    PUT    /api/v1/accounts/{id}               # 更新账号
    DELETE /api/v1/accounts/{id}               # 删除账号
    GET    /api/v1/accounts/{id}/messages      # 获取账号的消息列表
    
  错误示例:
    GET    /api/v1/getAccount/{id}             # 包含动词
    POST   /api/v1/account                     # 资源名单数
    GET    /api/v1/Accounts                    # 大写字母
    GET    /api/v1/accounts_list               # 下划线分隔
```

### 2. HTTP方法使用规范
```yaml
HTTP方法规范:
  GET:    查询操作，幂等，无副作用
  POST:   创建操作，非幂等
  PUT:    更新操作(全量)，幂等
  PATCH:  更新操作(部分)，幂等
  DELETE: 删除操作，幂等
  
  状态码规范:
    2xx: 成功
      200: 成功(GET/PUT/PATCH)
      201: 创建成功(POST)
      204: 删除成功(DELETE)
    4xx: 客户端错误
      400: 请求参数错误
      401: 未认证
      403: 无权限
      404: 资源不存在
      409: 资源冲突
    5xx: 服务端错误
      500: 服务器内部错误
      503: 服务不可用
```

## 📨 统一响应格式

### 1. 成功响应格式
```java
// ✅ 正确的响应格式
@Data
public class Result<T> {
    private Integer code;
    private String message;
    private T data;
    private Long timestamp;
    private String requestId;
    
    public static <T> Result<T> success(T data) {
        Result<T> result = new Result<>();
        result.setCode(200);
        result.setMessage("success");
        result.setData(data);
        result.setTimestamp(System.currentTimeMillis());
        result.setRequestId(MDC.get("requestId"));
        return result;
    }
}

// 控制器中的使用
@RestController
@RequestMapping("/api/v1/accounts")
public class AccountController {
    
    @GetMapping("/{id}")
    public Result<AccountDTO> getAccount(@PathVariable String id) {
        AccountDTO account = accountService.getAccount(getCurrentTenantId(), id);
        return Result.success(account);
    }
    
    @GetMapping
    public Result<PageResult<AccountDTO>> getAccounts(
            @RequestParam(defaultValue = "1") Integer pageNum,
            @RequestParam(defaultValue = "20") Integer pageSize) {
        PageResult<AccountDTO> pageResult = accountService.getAccounts(
            getCurrentTenantId(), pageNum, pageSize);
        return Result.success(pageResult);
    }
}
```

### 2. 错误响应格式
```java
// ✅ 统一异常处理
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(ValidationException.class)
    public Result<Void> handleValidationException(ValidationException e) {
        return Result.error(ErrorCode.PARAM_ERROR, e.getMessage());
    }
    
    @ExceptionHandler(BusinessException.class)
    public Result<Void> handleBusinessException(BusinessException e) {
        return Result.error(e.getErrorCode(), e.getMessage());
    }
    
    @ExceptionHandler(Exception.class)
    public Result<Void> handleException(Exception e) {
        log.error("系统异常", e);
        return Result.error(ErrorCode.SYSTEM_ERROR, "系统异常，请稍后重试");
    }
}

// 错误码定义
public enum ErrorCode {
    SUCCESS(200, "操作成功"),
    PARAM_ERROR(400, "参数错误"),
    UNAUTHORIZED(401, "未登录"),
    FORBIDDEN(403, "无权限"),
    NOT_FOUND(404, "资源不存在"),
    CONFLICT(409, "资源冲突"),
    SYSTEM_ERROR(500, "系统错误"),
    
    // 业务错误码
    ACCOUNT_NOT_FOUND(40001, "账号不存在"),
    ACCOUNT_QUOTA_EXCEEDED(40002, "账号配额已满"),
    MESSAGE_SEND_FAILED(40003, "消息发送失败");
    
    private final Integer code;
    private final String message;
}
```

## 🔐 认证授权规则

### 1. JWT Token处理
```java
// ✅ 正确的认证实现
@Component
public class JwtAuthenticationFilter implements Filter {
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, 
                        FilterChain chain) throws IOException, ServletException {
        
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        String token = getTokenFromRequest(httpRequest);
        
        if (StringUtils.hasText(token) && jwtUtils.validateToken(token)) {
            // 解析用户信息
            UserContext userContext = jwtUtils.parseToken(token);
            
            // 设置上下文
            UserContextHolder.setContext(userContext);
            
            // 设置请求ID
            String requestId = UUID.randomUUID().toString();
            MDC.put("requestId", requestId);
            MDC.put("tenantId", userContext.getTenantId());
            MDC.put("userId", userContext.getUserId());
        }
        
        try {
            chain.doFilter(request, response);
        } finally {
            // 清理上下文
            UserContextHolder.clear();
            MDC.clear();
        }
    }
    
    private String getTokenFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}

// 用户上下文
@Data
public class UserContext {
    private String userId;
    private String tenantId;
    private String username;
    private List<String> roles;
    private List<String> permissions;
}
```

### 2. 权限控制
```java
// ✅ 方法级权限控制
@RestController
@RequestMapping("/api/v1/accounts")
public class AccountController {
    
    @GetMapping("/{id}")
    @PreAuthorize("hasPermission('account', 'read')")
    public Result<AccountDTO> getAccount(@PathVariable String id) {
        return Result.success(accountService.getAccount(getCurrentTenantId(), id));
    }
    
    @PostMapping
    @PreAuthorize("hasPermission('account', 'create')")
    public Result<AccountDTO> createAccount(@Valid @RequestBody CreateAccountRequest request) {
        AccountDTO account = accountService.createAccount(getCurrentTenantId(), request);
        return Result.success(account);
    }
    
    @DeleteMapping("/{id}")
    @PreAuthorize("hasPermission('account', 'delete')")
    public Result<Void> deleteAccount(@PathVariable String id) {
        accountService.deleteAccount(getCurrentTenantId(), id);
        return Result.success();
    }
    
    private String getCurrentTenantId() {
        return UserContextHolder.getContext().getTenantId();
    }
}
```

## 📋 参数验证规则

### 1. 请求参数验证
```java
// ✅ 正确的参数验证
@Data
@Valid
public class CreateAccountRequest {
    
    @NotBlank(message = "账号名称不能为空")
    @Length(min = 2, max = 50, message = "账号名称长度必须在2-50之间")
    private String accountName;
    
    @NotBlank(message = "企微GUID不能为空")
    @Pattern(regexp = "^[a-zA-Z0-9_-]+$", message = "企微GUID格式不正确")
    private String weWorkGuid;
    
    @Email(message = "邮箱格式不正确")
    private String email;
    
    @NotNull(message = "配置信息不能为空")
    @Valid
    private AccountConfigDTO config;
    
    @JsonProperty("account_name")
    public String getAccountName() {
        return accountName;
    }
}

@Data
public class AccountConfigDTO {
    
    @NotNull(message = "最大联系人数量不能为空")
    @Min(value = 1, message = "最大联系人数量不能小于1")
    @Max(value = 10000, message = "最大联系人数量不能大于10000")
    private Integer maxContacts;
    
    @NotNull(message = "是否启用自动回复不能为空")
    private Boolean autoReplyEnabled;
}
```

### 2. 分页参数处理
```java
// ✅ 统一分页处理
@Data
public class PageQuery {
    
    @Min(value = 1, message = "页码不能小于1")
    private Integer pageNum = 1;
    
    @Min(value = 1, message = "页大小不能小于1")
    @Max(value = 100, message = "页大小不能大于100")
    private Integer pageSize = 20;
    
    private String sortBy;
    
    @Pattern(regexp = "^(asc|desc)$", message = "排序方向只能是asc或desc")
    private String sortOrder = "desc";
}

@Data
public class PageResult<T> {
    private List<T> records;
    private Long total;
    private Integer pageNum;
    private Integer pageSize;
    private Integer pages;
    
    public static <T> PageResult<T> of(List<T> records, Long total, 
                                      Integer pageNum, Integer pageSize) {
        PageResult<T> result = new PageResult<>();
        result.setRecords(records);
        result.setTotal(total);
        result.setPageNum(pageNum);
        result.setPageSize(pageSize);
        result.setPages((int) Math.ceil((double) total / pageSize));
        return result;
    }
}
```

## 🔄 异步处理规则

### 1. 异步接口设计
```java
// ✅ 异步任务处理
@RestController
@RequestMapping("/api/v1/messages")
public class MessageController {
    
    @PostMapping("/batch-send")
    public Result<String> batchSendMessages(@Valid @RequestBody BatchSendRequest request) {
        // 创建异步任务
        String taskId = messageService.createBatchSendTask(getCurrentTenantId(), request);
        return Result.success(taskId);
    }
    
    @GetMapping("/tasks/{taskId}")
    public Result<TaskStatusDTO> getTaskStatus(@PathVariable String taskId) {
        TaskStatusDTO status = messageService.getTaskStatus(getCurrentTenantId(), taskId);
        return Result.success(status);
    }
}

@Service
public class MessageService {
    
    @Async("taskExecutor")
    public CompletableFuture<Void> processBatchSendTask(String tenantId, String taskId, 
                                                       BatchSendRequest request) {
        try {
            // 更新任务状态为进行中
            taskService.updateTaskStatus(taskId, TaskStatus.RUNNING);
            
            // 执行批量发送
            List<String> messageIds = batchSendMessages(tenantId, request);
            
            // 更新任务状态为完成
            taskService.updateTaskStatus(taskId, TaskStatus.COMPLETED, messageIds);
            
        } catch (Exception e) {
            // 更新任务状态为失败
            taskService.updateTaskStatus(taskId, TaskStatus.FAILED, e.getMessage());
            throw e;
        }
        return CompletableFuture.completedFuture(null);
    }
}
```

### 2. 回调处理
```java
// ✅ 回调接口设计
@RestController
@RequestMapping("/api/v1/callbacks")
public class CallbackController {
    
    @PostMapping("/wework/message-status")
    public Result<Void> handleMessageStatusCallback(@RequestBody MessageStatusCallback callback,
                                                   HttpServletRequest request) {
        // 验证回调签名
        if (!callbackService.verifySignature(request, callback)) {
            throw new BusinessException(ErrorCode.INVALID_SIGNATURE);
        }
        
        // 异步处理回调
        callbackService.processMessageStatusCallback(callback);
        
        return Result.success();
    }
}

@Component
public class CallbackService {
    
    @Async("callbackExecutor")
    public void processMessageStatusCallback(MessageStatusCallback callback) {
        try {
            // 更新消息状态
            messageService.updateMessageStatus(callback.getMessageId(), 
                                             callback.getStatus());
            
            // 发送状态变更事件
            eventPublisher.publishMessageStatusChanged(callback);
            
        } catch (Exception e) {
            log.error("处理消息状态回调失败", e);
            // 可以考虑重试机制
        }
    }
    
    public boolean verifySignature(HttpServletRequest request, Object callback) {
        String signature = request.getHeader("X-Signature");
        String timestamp = request.getHeader("X-Timestamp");
        
        // 验证时间戳(防重放攻击)
        if (Math.abs(System.currentTimeMillis() - Long.parseLong(timestamp)) > 300000) {
            return false;
        }
        
        // 验证签名
        String expectedSignature = calculateSignature(callback, timestamp);
        return signature.equals(expectedSignature);
    }
}
```

## 📊 API监控规则

### 1. 接口监控
```java
// ✅ 接口性能监控
@Aspect
@Component
public class ApiMonitorAspect {
    
    private final MeterRegistry meterRegistry;
    
    @Around("@annotation(org.springframework.web.bind.annotation.RequestMapping) || " +
            "@annotation(org.springframework.web.bind.annotation.GetMapping) || " +
            "@annotation(org.springframework.web.bind.annotation.PostMapping)")
    public Object monitorApi(ProceedingJoinPoint point) throws Throwable {
        String methodName = point.getSignature().getName();
        String className = point.getTarget().getClass().getSimpleName();
        String apiName = className + "." + methodName;
        
        Timer.Sample sample = Timer.start(meterRegistry);
        
        try {
            Object result = point.proceed();
            
            // 记录成功指标
            meterRegistry.counter("api.requests.total", 
                                "api", apiName, "status", "success").increment();
            
            return result;
            
        } catch (Exception e) {
            // 记录失败指标
            meterRegistry.counter("api.requests.total", 
                                "api", apiName, "status", "error").increment();
            throw e;
            
        } finally {
            // 记录响应时间
            sample.stop(Timer.builder("api.response.time")
                           .tag("api", apiName)
                           .register(meterRegistry));
        }
    }
}
```

### 2. 限流配置
```java
// ✅ 接口限流
@RestController
@RequestMapping("/api/v1/accounts")
public class AccountController {
    
    @GetMapping
    @RateLimiter(name = "account-query", fallbackMethod = "getAccountsFallback")
    public Result<PageResult<AccountDTO>> getAccounts(PageQuery query) {
        PageResult<AccountDTO> result = accountService.getAccounts(
            getCurrentTenantId(), query);
        return Result.success(result);
    }
    
    @PostMapping
    @RateLimiter(name = "account-create", fallbackMethod = "createAccountFallback")
    public Result<AccountDTO> createAccount(@Valid @RequestBody CreateAccountRequest request) {
        AccountDTO account = accountService.createAccount(getCurrentTenantId(), request);
        return Result.success(account);
    }
    
    // 降级方法
    public Result<PageResult<AccountDTO>> getAccountsFallback(PageQuery query, Exception e) {
        log.warn("账号查询接口限流，返回空结果");
        return Result.success(PageResult.empty());
    }
    
    public Result<AccountDTO> createAccountFallback(CreateAccountRequest request, Exception e) {
        log.warn("账号创建接口限流");
        throw new BusinessException(ErrorCode.RATE_LIMIT_EXCEEDED, "请求过于频繁，请稍后重试");
    }
}
```

**规则总结**:
- 所有API必须遵循RESTful设计规范
- 统一使用Result包装响应数据
- 必须进行参数验证和权限控制
- 异步操作需要提供任务状态查询接口
- 重要接口必须配置限流和监控
- 回调接口需要验证签名和防重放攻击